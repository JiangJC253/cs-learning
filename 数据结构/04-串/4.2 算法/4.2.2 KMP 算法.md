对于模式串 `T = "abaabc"` 
- 当*第六个*元素匹配失败时，可令主串指针*i不变*，模式串指针 `j=3`
- 当*第五个*元素匹配失败时，可令主串指针*i不变*，模式串指针 `j=2`
- 当*第四个*元素匹配失败时，可令主串指针*i不变*，模式串指针 `j=2`
- 当*第三个*元素匹配失败时，可令主串指针*i不变*，模式串指针 `j=1`
- 当*第二个*元素匹配失败时，可令主串指针*i不变*，模式串指针 `j=1`
- 当*第一个*元素匹配失败时，可令主串指针*i不变*，模式串指针 `j=0, i++, j++`
通过一个 `next` 数组来存储模式串 T 的序号，`next` 数组只和模式串有关，和主串无关
用代码表示刚才的逻辑：
```c
if(s[i] != T[j])
	j = next[j];
if(j == 0){
	i++; j++;
}
```
***KMP 算法的逻辑***：
根据模式串 T ，求出 `next` 数组 --> 利用 `next` 数组进行匹配（**主串指针不回溯**）
***
先来看第二步：利用 `next` 数组进行匹配（**主串指针不回溯**）
代码实现：
```c
int Index_KMP(SString S, SString T, int next[]){
	int i = 1, j = 1;
	while(i <= S.length && j <= T.length){
		if(j == 0 || S.ch[i] == T.ch[j]){
			++i; ++j;  // 继续比较后续字符
		}else
			j = next[j];  // 模式串向右移动
	}
	if(j > T.length)
		return i-T.length;  // 匹配成功
	else
		return 0;
}
```
***
朴素模式匹配算法，最坏时间复杂度：$O(nm)$ 
KMP算法，最坏时间复杂度：$O(n+m)$ 
- 其中，求 `next` 数组时间复杂度 $O(m)$ 
- 在考研中，只需要大家能够手动求出 `next` 数组就行
