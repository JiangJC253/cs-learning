如何找到指定结点 p 在中序遍历序列中的前驱？如何找到 p 的中序后继？
思路：
	从根结点出发，重新进行一次中序遍历，指针 q 记录当前访问的结点，获取 pre 记录上一个被访问的结点
	当 $q==p$ 时，pre 为前驱
	当 $pre == p$ 时，q 为后继
缺点：
	找前驱、后继很不方便；遍历操作必须从根开始
```c
// 中序遍历
void InOrder(BiTree T){
	if(T != NULL){
		InOrder(T->lchild);  // 递归遍历左子树
		visit(T);            // 访问根结点
		InOrder(T->rchild);  // 递归遍历右子树
	}
}
```

# 中序线索二叉树
由于 n 个结点的二叉树，有 n+1 个空链域，那么我们就可以使用这些空链域来记录前驱、后继的信息
- 前驱线索——由左孩子指针充当
- 后继线索——由右孩子指针充当
指向前驱、后继的指针称为“线索”
***
如何找到 G 的后继线索？
ans：只要找到 G 的后继线索就可以了
那么根据以上答案，想要在任意一个结点开始遍历，这个事情也是可行的
***
为了区别左右孩子指针和“线索”，我们需要增加两个标志位 tag
```c
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode *lchild, *rchild;
	int ltag, rtag;  // 左右线索标志
}ThreadNode, *ThreadTree;

/*
* 当 ltag == 0，表示指针指向孩子
* 当 ltag == 1，表示指针指向“线索”
*/
```
此外还有 先序线索二叉树 和 后序线索二叉树
***
注意，容易混淆的是：
- 中序线索二叉树——线索指的是：中序前驱、中序后继
- 先序线索二叉树——线索指的是：先序前驱、先序后继
- 后序线索二叉树——线索指的是：后序前驱，后序后继
