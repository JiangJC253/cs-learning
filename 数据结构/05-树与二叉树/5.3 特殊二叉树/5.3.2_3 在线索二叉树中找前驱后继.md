# 中序线索二叉树找中序后继
在中序线索二叉树中找到指定结点 `*p` 的 *中序后继* `next` 
1. 若 `p->rtag == 1`，则 `next = p->rchild`
2. 若 `p->rtag == 0`，则 p 必有右孩子，`next` 就是 p 的右子树中，最左下角的结点mkkkkkkkkkkkkkkkk
```c
// 找到以 p 为根的子树中，第一个被中序遍历的结点
ThreadNode *Firstnode(ThreadNode *p){
	// 循环找到最左下结点（不一定是叶子结点）
	while(p->ltag == 0) p = p->lchild;
	return p;
}

// 在中序线索二叉树中找到结点 p 的后继结点
ThreadNode *Nextnode(ThreadNode *p){
	// 右子树中最左下结点
	if(p->rtag == 0) return Firstnode(p->rchild);
	else return p->rchild;  // rtag == 1直接返回后继线索
}

// 对中序线索二叉树进行中序遍历（利用线索实现的非递归算法）
void Inorder(ThreadNode *T){
	for(ThreadNode *p = Firstnode(T); p != NULL; p = Nextnode(p)) 
			visit(p);
}
```
# 先序线索二叉树
## 找先序后继
在先序线索二叉树中找到指定结点 `*p` 的 *先序后继* `next`
1. 若 `p->rtag == 1` ，则 `next = p->rchild` 
2. 若 `p->ratg == 0`
……

## 找先序前驱
在先序线索二叉树中找到指定结点 `*p` 的 *先序前驱* `pre`
1. 若 `p->ltag == 1` ，则 `pre = p->lchild` 
2. 若 `p->latg == 0`
先序遍历中，左右子树中的结点只可能是根的后继，不可能是前驱
1. 如果能找到p的父结点，且p是左孩子——p的父结点即为其前驱
2. 如果能找到p的父结点，且p是右孩子，其左兄弟为空——p的父结点即为其前驱
3. 如果能找到p的父结点，且p是右孩子，其左兄弟非空——p的前驱为 *左兄弟子树中 最后一个被先序遍历的结点* 
# 后序线索二叉树
## 找后序前驱
在后序线索二叉树中找到指定结点 `*p` 的 *后序前驱* `pre`
1. 若 `p->ltag == 1` ，则 `pre = p->lchild` 
2. 若 `p->latg == 0`， p必有左孩子
	- 若p有右孩子，则后序前驱为 *右孩子* 
	- 如果p没有右孩子，则后序前驱为 *左孩子* 
## 找后序后继
在后序线索二叉树中找到指定结点 `*p` 的 *后序后继* `next`
1. 若 `p->rtag == 1` ，则 `next = p->rchild` 
2. 若 `p->ratg == 0`， p必有右孩子
后序遍历中，左右子树中的结点只可能是根的前驱，不可能是后继
***
该用三叉链表可以找到父结点
1. 如果能找到 p 的父结点，且 p 是右孩子——p 的父结点即为其后继
2. 如果能找到 p 的父结点，且 p 是左孩子，其右兄弟为空——p 的父结点即为其后继
3. 如果能找到 p 的父结点，且 p 是左孩子，其右兄弟非空——p 的后继为 *右兄弟子树中 第一个被后序遍历的结点*
4. 如果 p 是根结点，则 p 没有后序后继

# 知识回顾与重要考点

|     | 中序线索二叉树 | 先序线索二叉树 | 后序线索二叉树                   |
| --- | ------- | ------- | ------------------------- |
| 找前驱 | 可以      | 不行      | 可以                        |
| 找后继 | 可以      | 可以      | 不行（除非用三叉链表，或者土办法从根开始遍历寻找） |
